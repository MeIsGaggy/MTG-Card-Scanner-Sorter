# ============================== CARD SCANNER CONFIG (Ender 3 S1 + Klipper) ==============================
# Motion-only setup for MTG card sorting. Heaters/fans are neutralized. Scanner app drives pass/fail.

[delayed_gcode INIT_VAC_ZERO]
initial_duration: 1
gcode:
  # Define current physical position as OFF=0 at firmware start
  MANUAL_STEPPER STEPPER=VAC SET_POSITION=0

# ===== UI Helpers =====
[gcode_macro SORTER_HELP]
description: Show the short how-to for the card scanner
gcode:
  { action_respond_info(
    "CARD SCANNER — Quick start:\\n"
    "1) SORTER_HOME (or RUN_SORTER_INTERACTIVE COUNT=1 HOME=1)\\n"
    "2) SET_START_HEIGHT_GUIDED  -> then SET_START_HEIGHT_OK (measures Start1 & Start2)\\n"
    "3) SORT_ONE (or SORT_10). While at scan, your app sends SCAN_OK / SCAN_FAIL.\\n"
    "Useful: SHOW_STACKS, CANCEL_SCAN_WAIT, SET_TIMEOUT_S VALUE=<sec> (0=infinite)"
  ) }

[gcode_macro SORT_ONE]
description: Pick 1 card and run one full scan/place cycle
gcode:
  RUN_SORTER_INTERACTIVE COUNT=1 HOME=0

[gcode_macro SORT_10]
description: Pick and process 10 cards
gcode:
  RUN_SORTER_INTERACTIVE COUNT=10 HOME=0

[gcode_macro SET_TIMEOUT_S]
description: Set scan wait timeout (seconds). 0 = wait forever (no auto-fail)
gcode:
  {% set V = params.VALUE|default(0)|int %}
  SET_GCODE_VARIABLE MACRO=SORTER_PARAMS VARIABLE=scan_timeout_s VALUE={V}
  { action_respond_info("Scan timeout set to %s" % ("infinite" if V==0 else ("%ds" % V))) }

[gcode_macro CANCEL_SCAN_WAIT]
description: Cancel any active scan wait / countdown ticks
gcode:
  SET_GCODE_VARIABLE MACRO=VISION_STATE VARIABLE=busy VALUE=0
  SET_GCODE_VARIABLE MACRO=VISION_STATE VARIABLE=timer_left  VALUE=0
  SET_GCODE_VARIABLE MACRO=VISION_STATE VARIABLE=timer_total VALUE=0
  UPDATE_DELAYED_GCODE ID=VISION_TIMEOUT DURATION=0
  UPDATE_DELAYED_GCODE ID=VISION_TICK    DURATION=0
  RESPOND PREFIX=info MSG="Scan wait cancelled."

# ===== Includes / Core =====
[include fluidd.cfg]
# [include timelapse.cfg]

[mcu]
serial: /dev/serial/by-id/usb-1a86_USB_Serial-if00-port0
restart_method: command

[printer]
kinematics: cartesian
max_velocity: 100
max_accel: 750
max_z_velocity: 100
max_z_accel: 500
square_corner_velocity: 5.0

# ----- Axes -----
[stepper_x]
step_pin: PC2
dir_pin: PB9
enable_pin: !PC3
microsteps: 16
rotation_distance: 40
endstop_pin: !PA5
position_endstop: -10
position_max: 235
position_min: -15
homing_speed: 50

[stepper_y]
step_pin: PB8
dir_pin: PB7
enable_pin: !PC3
microsteps: 16
rotation_distance: 40
endstop_pin: !PA6
position_endstop: -8
position_max: 240
position_min: -13
homing_speed: 50

[stepper_z]
step_pin: PB6
dir_pin: !PB5
enable_pin: !PC3
microsteps: 16
rotation_distance: 8
endstop_pin: probe:z_virtual_endstop
position_max: 270
position_min: -10
homing_speed: 8

# ----- Probe (BLTouch) -----
[bltouch]
sensor_pin: ^PC14
control_pin: PC13
x_offset: -31.8
y_offset: -40.5
z_offset: 4.085
probe_with_touch_mode: true
stow_on_each_sample: false
samples: 1
samples_tolerance: 0.1
samples_tolerance_retries: 2
speed: 3.0

# === Custom safe home (unchanged) ===
[homing_override]
set_position_z: 0
axes: xyz
gcode:
  G90
  G1 Z75 F1200
  G28 X Y
  G1 X104 Y10 F6000
  G28 Z

# Optional: bed mesh
[bed_mesh]
speed: 120
mesh_min: 10, 10
mesh_max: 200, 194
probe_count: 4,4
algorithm: bicubic
fade_start: 1
fade_end: 10
fade_target: 0

# ----- QoL -----
[respond]
[display_status]
[pause_resume]
recover_velocity: 25
[idle_timeout]
timeout: 1800

# Temperatures (read-only)
[temperature_sensor bed_sensor]
sensor_type: EPCOS 100K B57560G104F
sensor_pin: PC4
min_temp: 0
max_temp: 110

[temperature_sensor raspberry_pi]
sensor_type: temperature_host
min_temp: 10
max_temp: 100

[temperature_sensor mcu_temp]
sensor_type: temperature_mcu
min_temp: 0
max_temp: 100

# ----- Neutralize print-related G-codes -----
[gcode_macro M104]
description: NO-OP (heating disabled)
gcode:
  RESPOND PREFIX=warn MSG="M104 ignored: heaters disabled"

[gcode_macro M109]
description: NO-OP (heating disabled)
gcode:
  RESPOND PREFIX=warn MSG="M109 ignored: heaters disabled"

[gcode_macro M140]
description: NO-OP (bed heating disabled)
gcode:
  RESPOND PREFIX=warn MSG="M140 ignored: bed disabled"

[gcode_macro M190]
description: NO-OP (bed heating disabled)
gcode:
  RESPOND PREFIX=warn MSG="M190 ignored: bed disabled"

[gcode_macro M106]
description: NO-OP (fans repurposed later)
gcode:
  RESPOND PREFIX=info MSG="M106 ignored: fans disabled"

[gcode_macro M107]
description: NO-OP
gcode:
  RESPOND PREFIX=info MSG="M107 ignored: fans disabled"

# ===== Sorter Coordinates / Motion Tunables =====
[gcode_macro SORTER_PARAMS]
# --- SCAN AREA (single) ---
variable_scan_xy:     104.0, 10.0  # one scan area only
# --- REJECT AREA (single) ---
variable_reject_xy:    53.80, 61.0

# --- LEGACY single-stack aliases (kept for compatibility; not used by new logic) ---
variable_input_xy:    120.0, 220.0
variable_finish_xy:    53.80, 61.0

# --- NEW: dual starts & dual finishes (EDIT THESE 4) ---
variable_input1_xy:   44.0, 225.0   # Start stack 1  ← set yours
variable_input2_xy:   181.0, 225.0   # Start stack 2  ← set yours
variable_finish1_xy:   44.0, 156.30   # Finish stack 1 ← set yours
variable_finish2_xy:   181.20, 156.30  # Finish stack 2 ← set yours

# Tool XY offset if your picker isn't centered to nozzle coords
variable_tool_offset_x: 0.0
variable_tool_offset_y: 0.0

# Heights & speeds
variable_clearance_z: 25.0         # minimum safe Z
variable_travel_z:    85.0         # travel height for XY moves while holding a card
variable_approach_z:  2.0
variable_pick_z:      -1.0
variable_place_z:     0.8
variable_pick_guard:  -2.5
variable_min_z_floor: -3.0

# Scan plane & head park pose (single scan area)
variable_scan_drop_z:   0.0           # Z where the card rests for scanning (bed plane)
variable_scan_head_xy: 104.0, 135.0   # HEAD PARK XY during scan
variable_scan_head_z:  109.085           # HEAD PARK Z during scan
variable_finish_drop_z: 88.085          # Z to drop card for PASS
variable_reject_drop_z: 88.085          # Z to drop card for FAIL
variable_scan_h:        0.0           # legacy (not used for motion)
variable_xy_speed:    6000
variable_z_speed:     1500

# Timings (ms)
variable_dwell_pick_ms:     500
variable_dwell_scan_ms:     500
variable_dwell_release_ms:  200
variable_lift_after_pick:    75.0
variable_dwell_drop_ms:     500

# Probe speeds
variable_probe_fast: 5.0
variable_probe_slow: 1.5

# Vacuum tuning — simple symmetric half-turns
variable_vac_half_rev: 12.741
variable_vac_speed:    15
variable_vac_dwell_ms: 120
variable_pick_z_start: -2.5

# Shake (hitchhiker guard)
variable_shake_enable:        1
variable_shake_lift:          2.5
variable_shake_duration_ms:   500
variable_shake_step:          0.10
variable_shake_pulse_ms:      10
variable_shake_speed:         8000
variable_shake_accel:         8000

# Scan wait behavior
variable_scan_timeout_s:    0
variable_scan_warn_step_s: 10
variable_timeout_auto_fail: 0
gcode:
  G4 P0

# ===== Dynamic Stack Heights (DUAL) =====
[gcode_macro STACK_STATE]
variable_card_thickness: 0.305
# start stacks (measured separately)
variable_start1_h: 0.0
variable_start2_h: 0.0
# finish stacks (running totals)
variable_finish1_h: 0.0
variable_finish2_h: 0.0
variable_reject_h:  0.0
# which stack to pick next / which finish to drop next
variable_next_start_slot: 1
variable_next_finish_slot: 1
# source start slot of the *current* card (set by PICKUP_CARD)
variable_src_slot: 0
gcode: G4 P0

# ===== Vacuum Plunger Stepper (compound 1->3, 2->4; 3/2 same axle) =====
[manual_stepper VAC]
step_pin: PB4
dir_pin: PB3                      # ON = +X, OFF = −X (non-inverted)
enable_pin: !PC3
microsteps: 16
rotation_distance: 25.482
gear_ratio: 3:1, 2:1              # overall 6:1
full_steps_per_rotation: 200
velocity: 100
accel: 400
position_min: -200
position_max:  200

# ===== Setup / Calibration =====
[gcode_macro SORTER_HOME]
description: Home and raise to safe Z
gcode:
  G90
  G28
  _SAFE_RAISE
  SET_START_HEIGHT_GUIDED

[gcode_macro SET_START_HEIGHT_GUIDED]
description: Move to safe Z and prompt to place start stacks
gcode:
  {% set P = printer["gcode_macro SORTER_PARAMS"] %}
  G90
  {% if printer.toolhead.position.z|float < P.clearance_z %}
    G1 Z{P.clearance_z} F{P.z_speed}
  {% endif %}
  G1 Z100 F{P.z_speed}
  RESPOND PREFIX=info MSG="Place BOTH START stacks, then run: SET_START_HEIGHT_OK"

[gcode_macro SET_START_HEIGHT_OK]
description: Probe both START stack tops and save as baselines (safe travel + delayed saves)
gcode:
  {% set P = printer["gcode_macro SORTER_PARAMS"] %}

  # --- probe start 1 ---
  _MOVE_TOOL_SAFE X={P.input1_xy[0]} Y={P.input1_xy[1]}
  PROBE SPEED={P.probe_fast}
  G91
  G1 Z2 F{P.z_speed}
  G90
  PROBE SPEED={P.probe_slow}
  M400
  UPDATE_DELAYED_GCODE ID=SET_START1_SAVE DURATION=0.01

  # --- probe start 2 ---
  _MOVE_TOOL_SAFE X={P.input2_xy[0]} Y={P.input2_xy[1]}
  PROBE SPEED={P.probe_fast}
  G91
  G1 Z2 F{P.z_speed}
  G90
  PROBE SPEED={P.probe_slow}
  M400
  UPDATE_DELAYED_GCODE ID=SET_START2_SAVE DURATION=0.01

  # finalize after both saves
  UPDATE_DELAYED_GCODE ID=SET_STARTS_DONE DURATION=0.02

[delayed_gcode SET_START1_SAVE]
gcode:
  {% set z = printer.probe.last_z_result|float %}
  SET_GCODE_VARIABLE MACRO=STACK_STATE VARIABLE=start1_h VALUE={z}
  { action_respond_info("Start1 height = %.3f mm" % (z)) }

[delayed_gcode SET_START2_SAVE]
gcode:
  {% set z = printer.probe.last_z_result|float %}
  SET_GCODE_VARIABLE MACRO=STACK_STATE VARIABLE=start2_h VALUE={z}
  { action_respond_info("Start2 height = %.3f mm" % (z)) }

[delayed_gcode SET_STARTS_DONE]
gcode:
  SET_GCODE_VARIABLE MACRO=STACK_STATE VARIABLE=finish1_h VALUE=0.0
  SET_GCODE_VARIABLE MACRO=STACK_STATE VARIABLE=finish2_h VALUE=0.0
  SET_GCODE_VARIABLE MACRO=STACK_STATE VARIABLE=reject_h  VALUE=0.0
  SET_GCODE_VARIABLE MACRO=STACK_STATE VARIABLE=next_start_slot  VALUE=1
  SET_GCODE_VARIABLE MACRO=STACK_STATE VARIABLE=next_finish_slot VALUE=1
  HOVER_STACK SLOT=1
  { action_respond_info("Both start heights saved. Ready!") }

[gcode_macro SET_CARD_THICKNESS]
description: Set card thickness (mm); default 0.305
gcode:
  {% set T = params.T|default(0.305)|float %}
  SET_GCODE_VARIABLE MACRO=STACK_STATE VARIABLE=card_thickness VALUE={T}
  { action_respond_info("Card thickness set to %.3f mm" % (T)) }

[gcode_macro INIT_STACKS]
description: Manually set START1/START2 heights (mm) and reset outputs; e.g., INIT_STACKS START1=5.0 START2=5.2
gcode:
  {% set S1 = params.START1|float %}
  {% set S2 = params.START2|float %}
  SET_GCODE_VARIABLE MACRO=STACK_STATE VARIABLE=start1_h  VALUE={S1}
  SET_GCODE_VARIABLE MACRO=STACK_STATE VARIABLE=start2_h  VALUE={S2}
  SET_GCODE_VARIABLE MACRO=STACK_STATE VARIABLE=finish1_h VALUE=0.0
  SET_GCODE_VARIABLE MACRO=STACK_STATE VARIABLE=finish2_h VALUE=0.0
  SET_GCODE_VARIABLE MACRO=STACK_STATE VARIABLE=reject_h  VALUE=0.0
  SET_GCODE_VARIABLE MACRO=STACK_STATE VARIABLE=next_start_slot  VALUE=1
  SET_GCODE_VARIABLE MACRO=STACK_STATE VARIABLE=next_finish_slot VALUE=1
  RESPOND PREFIX=info MSG="Stacks initialized"

[gcode_macro SET_START_FROM_CURRENT]
description: Use current Z as BOTH START heights (quick/rough)
gcode:
  {% set Z = printer.toolhead.position.z|float %}
  SET_GCODE_VARIABLE MACRO=STACK_STATE VARIABLE=start1_h  VALUE={Z}
  SET_GCODE_VARIABLE MACRO=STACK_STATE VARIABLE=start2_h  VALUE={Z}
  SET_GCODE_VARIABLE MACRO=STACK_STATE VARIABLE=finish1_h VALUE=0.0
  SET_GCODE_VARIABLE MACRO=STACK_STATE VARIABLE=finish2_h VALUE=0.0
  SET_GCODE_VARIABLE MACRO=STACK_STATE VARIABLE=reject_h  VALUE=0.0
  SET_GCODE_VARIABLE MACRO=STACK_STATE VARIABLE=next_start_slot  VALUE=1
  SET_GCODE_VARIABLE MACRO=STACK_STATE VARIABLE=next_finish_slot VALUE=1
  HOVER_STACK SLOT=1
  RESPOND PREFIX=info MSG="Start heights set from current Z"

# ===== Vacuum Control =====
[gcode_macro VAC_ON]
description: Engage vacuum — move to absolute ON (idempotent)
gcode:
  {% set P = printer["gcode_macro SORTER_PARAMS"] %}
  MANUAL_STEPPER STEPPER=VAC ENABLE=1
  MANUAL_STEPPER STEPPER=VAC SET_POSITION=0
  MANUAL_STEPPER STEPPER=VAC MOVE={ P.vac_half_rev } SPEED={ P.vac_speed }
  G4 P{ P.vac_dwell_ms }

[gcode_macro VAC_OFF]
description: Release vacuum — move to absolute OFF (idempotent)
gcode:
  {% set P = printer["gcode_macro SORTER_PARAMS"] %}
  MANUAL_STEPPER STEPPER=VAC ENABLE=1
  MANUAL_STEPPER STEPPER=VAC SET_POSITION={ P.vac_half_rev }
  MANUAL_STEPPER STEPPER=VAC MOVE=0 SPEED={ P.vac_speed }
  G4 P{ P.vac_dwell_ms }

[gcode_macro VAC_ZERO]
description: Zero VAC logical position (no movement)
gcode:
  MANUAL_STEPPER STEPPER=VAC SET_POSITION=0

# ===== Motion Helpers =====
[gcode_macro _SAFE_RAISE]
gcode:
  {% set P = printer["gcode_macro SORTER_PARAMS"] %}
  G90
  {% set tgt = printer.toolhead.position.z|float %}
  {% if tgt < P.clearance_z %}{% set tgt = P.clearance_z %}{% endif %}
  G1 Z{tgt} F{P.z_speed}

[gcode_macro _RAISE_TO_TRAVEL]
gcode:
  {% set P = printer["gcode_macro SORTER_PARAMS"] %}
  G90
  {% set cur  = printer.toolhead.position.z|float %}
  {% set base = P.travel_z|float %}
  {% set need = (P.finish_drop_z if P.finish_drop_z > P.reject_drop_z else P.reject_drop_z)|float + 2.0 %}
  {% if need > base %}{% set base = need %}{% endif %}
  {% set tgt = base if base > cur else cur %}
  G1 Z{tgt} F{P.z_speed}

[gcode_macro _MOVE_TOOL_SAFE]
description: Always raise to safe travel then XY with tool offsets
gcode:
  {% set X = params.X|float %}
  {% set Y = params.Y|float %}
  _RAISE_TO_TRAVEL
  _MOVE_TOOL X={X} Y={Y}


[gcode_macro _HOP]
gcode:
  {% set P = printer["gcode_macro SORTER_PARAMS"] %}
  G90
  {% set tgt = printer.toolhead.position.z|float %}
  {% if tgt < P.clearance_z %}{% set tgt = P.clearance_z %}{% endif %}
  G1 Z{tgt} F{P.z_speed}

[gcode_macro _MOVE_XY]
gcode:
  {% set X = params.X|float %}
  {% set Y = params.Y|float %}
  {% set P = printer["gcode_macro SORTER_PARAMS"] %}
  G90
  G1 X{X} Y{Y} F{P.xy_speed}

[gcode_macro _MOVE_TOOL]
gcode:
  {% set TX = params.X|float %}
  {% set TY = params.Y|float %}
  {% set P   = printer["gcode_macro SORTER_PARAMS"] %}
  {% set NX = TX - P.tool_offset_x|float %}
  {% set NY = TY - P.tool_offset_y|float %}
  G90
  G1 X{NX} Y{NY} F{P.xy_speed}

[gcode_macro _MOVE_Z]
gcode:
  {% set Zt  = params.Z|float %}
  {% set P   = printer["gcode_macro SORTER_PARAMS"] %}
  {% set Zcl = Zt if Zt > P.min_z_floor else P.min_z_floor %}
  G90
  G1 Z{Zcl} F{P.z_speed}

[gcode_macro _DWELL_MS]
description: Millisecond pause helper (wraps G4)
gcode:
  {% set P = params.P|default(200)|int %}
  G4 P{P}

# ===== Hover helpers for dual starts =====
[gcode_macro HOVER_STACK]
description: Hover above specified start stack SLOT=1|2
gcode:
  {% set P = printer["gcode_macro SORTER_PARAMS"] %}
  {% set S = printer["gcode_macro STACK_STATE"] %}
  {% set slot = params.SLOT|default(1)|int %}
  {% set surf = (S.start1_h if slot==1 else S.start2_h)|float %}
  {% set floor = P.min_z_floor|float %}
  {% set target = (surf + P.approach_z)|float %}
  {% if target < floor %}{% set target = floor %}{% endif %}
  G90
  G1 Z{target} F{P.z_speed}

# Backwards compatible alias – hovers above the *next* start stack
[gcode_macro _HOVER_START]
gcode:
  HOVER_STACK SLOT={printer["gcode_macro STACK_STATE"].next_start_slot|int}

# ===== Vision/Scan Orchestration =====
[gcode_macro VISION_STATE]
variable_busy: 0
variable_job: 0
variable_timer_left: 0
variable_timer_total: 0
variable_elapsed: 0
gcode: G4 P0

[gcode_macro START_SCAN_WAIT]
description: Legacy wrapper to arm scan wait (no READY emitted)
gcode:
  {% set P = printer["gcode_macro SORTER_PARAMS"] %}
  ARM_SCAN_WAIT T={params.T|default(P.scan_timeout_s)|int}

[delayed_gcode VISION_TIMEOUT]
gcode:
  {% if printer["gcode_macro VISION_STATE"].busy|int == 1 %}
    SET_GCODE_VARIABLE MACRO=VISION_STATE VARIABLE=busy VALUE=0
    RESPOND PREFIX=warn MSG="Scan TIMEOUT -> treating as FAIL"
    SCAN_FAIL
  {% endif %}

[delayed_gcode VISION_TICK]
gcode:
  {% set V = printer["gcode_macro VISION_STATE"] %}
  {% if V.busy|int == 1 %}
    {% set W = printer["gcode_macro SORTER_PARAMS"].scan_warn_step_s|int %}
    {% set left = (V.timer_left|int - W) if (V.timer_left|int > 0) else 0 %}
    {% set elap = (V.elapsed|int + W) %}
    SET_GCODE_VARIABLE MACRO=VISION_STATE VARIABLE=timer_left VALUE={left}
    SET_GCODE_VARIABLE MACRO=VISION_STATE VARIABLE=elapsed    VALUE={elap}
    { action_respond_info("Scan ticking: %ds elapsed, %s left" %
        (elap, ("∞" if V.timer_total|int==0 else ("%ds" % left)))) }
    UPDATE_DELAYED_GCODE ID=VISION_TICK DURATION={W}
  {% endif %}

[gcode_macro ARM_SCAN_WAIT]
description: Arm scanner wait state & timers WITHOUT printing READY_TO_SCAN
gcode:
  {% set P  = printer["gcode_macro SORTER_PARAMS"] %}
  {% set V  = printer["gcode_macro VISION_STATE"] %}
  {% set Tp = params.T|default(P.scan_timeout_s)|int %}
  {% set T  = 0 if Tp < 0 else Tp %}
  {% set W  = P.scan_warn_step_s|int if P.scan_warn_step_s|int > 0 else 10 %}

  {% if V.busy|int == 1 %}
    RESPOND PREFIX=warn MSG="ARM_SCAN_WAIT ignored (already busy on job=%d)" % (V.job)
    RETURN
  {% endif %}

  {% set job = (V.job|int) + 1 %}
  SET_GCODE_VARIABLE MACRO=VISION_STATE VARIABLE=job          VALUE={job}
  SET_GCODE_VARIABLE MACRO=VISION_STATE VARIABLE=busy         VALUE=1
  SET_GCODE_VARIABLE MACRO=VISION_STATE VARIABLE=timer_left   VALUE={T}
  SET_GCODE_VARIABLE MACRO=VISION_STATE VARIABLE=timer_total  VALUE={T}
  SET_GCODE_VARIABLE MACRO=VISION_STATE VARIABLE=elapsed      VALUE=0

  { action_respond_info("Scan armed (timeout=%s) job=%d" %
      (("infinite" if T == 0 else ("%ds" % T)), job)) }

  {% if T > 0 %} UPDATE_DELAYED_GCODE ID=VISION_TIMEOUT DURATION={T} {% endif %}
  UPDATE_DELAYED_GCODE ID=VISION_TICK DURATION={W}

[gcode_macro MOVE_TO_SCAN]
description: Move to scan XY, drop card, park head, THEN arm & signal ready
gcode:
  {% set P = printer["gcode_macro SORTER_PARAMS"] %}

  # 1) Go to the single scan spot and drop the card
  _MOVE_TOOL_SAFE X={P.scan_xy[0]} Y={P.scan_xy[1]}
  _MOVE_Z Z={P.scan_drop_z}
  VAC_OFF
  _DWELL_MS P={P.dwell_release_ms}

  # 2) Park the head at the scan park pose (clear of camera view)
  _MOVE_Z Z={P.scan_head_z}
  _MOVE_TOOL_SAFE X={P.scan_head_xy[0]} Y={P.scan_head_xy[1]}
  _DWELL_MS P={P.dwell_scan_ms}

  M400
  ARM_SCAN_WAIT T={P.scan_timeout_s}
  M118 READY_TO_SCAN job={printer["gcode_macro VISION_STATE"].job}

# ===== Placement & Interactive Loop =====
[gcode_macro ISTATE]
variable_remaining: 0
gcode: G4 P0

# ----- PICKUP: alternate Start1 <-> Start2 -----
[gcode_macro PICKUP_CARD]
description: Pick top card from next START stack (alternates 1↔2)
gcode:
  {% set P = printer["gcode_macro SORTER_PARAMS"] %}
  {% set S = printer["gcode_macro STACK_STATE"] %}

  {% set slot = S.next_start_slot|int %}
  SET_GCODE_VARIABLE MACRO=STACK_STATE VARIABLE=src_slot VALUE={slot}

  {% set tx = (P.input1_xy[0] if slot==1 else P.input2_xy[0])|float %}
  {% set ty = (P.input1_xy[1] if slot==1 else P.input2_xy[1])|float %}
  {% set surf  = (S.start1_h if slot==1 else S.start2_h)|float %}
  {% set guard = (surf + P.pick_guard)|float %}
  {% set pre   = (surf + P.pick_z_start)|float %}
  {% set pre_target = pre if pre > guard else guard %}

  _MOVE_TOOL_SAFE X={tx} Y={ty}
  _MOVE_Z Z={pre_target}
  VAC_ON
  _DWELL_MS P={P.dwell_pick_ms}

  {% if P.shake_enable|int == 1 %}
    _MOVE_Z Z={pre_target + P.shake_lift}
    VIBRATE_X DURATION_MS={P.shake_duration_ms|int} STEP={P.shake_step} PULSE_MS={P.shake_pulse_ms|int} SPEED={P.shake_speed|int} ACCEL={P.shake_accel|int}
  {% endif %}

  _MOVE_Z Z={pre_target + P.lift_after_pick}
  _RAISE_TO_TRAVEL

# ----- FINISH placement helpers -----
[gcode_macro PLACE_FINISHED_SLOT]
description: Hover-drop to FINISH slot SLOT=1|2 (fixed Z)
gcode:
  {% set P = printer["gcode_macro SORTER_PARAMS"] %}
  {% set slot = params.SLOT|default(1)|int %}
  {% set fx = (P.finish1_xy[0] if slot==1 else P.finish2_xy[0])|float %}
  {% set fy = (P.finish1_xy[1] if slot==1 else P.finish2_xy[1])|float %}
  _RAISE_TO_TRAVEL
  _MOVE_TOOL X={fx} Y={fy}
  _MOVE_Z Z={P.finish_drop_z}
  M400
  _DWELL_MS P=120
  VAC_OFF
  _DWELL_MS P={P.dwell_release_ms}
  _RAISE_TO_TRAVEL

# Backward-compatible: PLACE_FINISHED drops to next_finish_slot and toggles
[gcode_macro PLACE_FINISHED]
description: Hover-drop to FINISH (auto-alternate 1↔2)
gcode:
  {% set S = printer["gcode_macro STACK_STATE"] %}
  {% set slot = S.next_finish_slot|int %}
  PLACE_FINISHED_SLOT SLOT={slot}
  SET_GCODE_VARIABLE MACRO=STACK_STATE VARIABLE=next_finish_slot VALUE={ 2 if slot==1 else 1 }


[gcode_macro PLACE_REJECT]
description: Hover-drop to REJECT (fixed Z)
gcode:
  {% set P = printer["gcode_macro SORTER_PARAMS"] %}
  _RAISE_TO_TRAVEL
  _MOVE_TOOL X={P.reject_xy[0]} Y={P.reject_xy[1]}
  _MOVE_Z Z={P.reject_drop_z}
  M400
  _DWELL_MS P=120
  VAC_OFF
  _DWELL_MS P={P.dwell_release_ms}
  _RAISE_TO_TRAVEL

# ----- SCAN results -----
[gcode_macro SCAN_OK]
description: OK → pick at scan, drop to FINISH (alternates 1↔2), update heights
gcode:
  {% set V = printer["gcode_macro VISION_STATE"] %}
  {% if V.busy|int != 1 %}
    RESPOND PREFIX=warn MSG="SCAN_OK ignored (no scan pending)"
  {% else %}
    UPDATE_DELAYED_GCODE ID=VISION_TIMEOUT DURATION=0
    UPDATE_DELAYED_GCODE ID=VISION_TICK    DURATION=0
    SET_GCODE_VARIABLE MACRO=VISION_STATE VARIABLE=busy VALUE=0
    M118 ACK_SCAN_OK job={printer["gcode_macro VISION_STATE"].job}

    {% set P = printer["gcode_macro SORTER_PARAMS"] %}
    {% set S = printer["gcode_macro STACK_STATE"] %}

    _MOVE_TOOL_SAFE X={P.scan_xy[0]} Y={P.scan_xy[1]}
    _MOVE_Z Z={P.scan_drop_z}
    VAC_ON
    _DWELL_MS P=150
    _MOVE_Z Z={P.travel_z}

    {% set fslot = S.next_finish_slot|int %}
    PLACE_FINISHED_SLOT SLOT={fslot}
    SET_GCODE_VARIABLE MACRO=STACK_STATE VARIABLE=next_finish_slot VALUE={ 2 if fslot==1 else 1 }

    {% set src = S.src_slot|int %}
    {% set t   = S.card_thickness|float %}
    {% set new_s1 = (S.start1_h - t)|float if src==1 else S.start1_h|float %}
    {% set new_s2 = (S.start2_h - t)|float if src==2 else S.start2_h|float %}
    {% set new_f1 = (S.finish1_h + t)|float if fslot==1 else S.finish1_h|float %}
    {% set new_f2 = (S.finish2_h + t)|float if fslot==2 else S.finish2_h|float %}
    SET_GCODE_VARIABLE MACRO=STACK_STATE VARIABLE=start1_h  VALUE={new_s1}
    SET_GCODE_VARIABLE MACRO=STACK_STATE VARIABLE=start2_h  VALUE={new_s2}
    SET_GCODE_VARIABLE MACRO=STACK_STATE VARIABLE=finish1_h VALUE={new_f1}
    SET_GCODE_VARIABLE MACRO=STACK_STATE VARIABLE=finish2_h VALUE={new_f2}

    SET_GCODE_VARIABLE MACRO=STACK_STATE VARIABLE=next_start_slot VALUE={ 2 if src==1 else 1 }

    {% set remaining = (printer["gcode_macro ISTATE"].remaining|default(1))|int %}
    {% set next_remaining = remaining - 1 if remaining > 0 else 0 %}
    SET_GCODE_VARIABLE MACRO=ISTATE VARIABLE=remaining VALUE={next_remaining}

    {% if next_remaining > 0 %} SORTER_CYCLE_INTERACTIVE {% else %} RESPOND PREFIX=info MSG="Run complete." {% endif %}
  {% endif %}

[gcode_macro SCAN_FAIL]
description: FAIL → pick at scan, drop to REJECT, update heights
gcode:
  {% set V = printer["gcode_macro VISION_STATE"] %}
  {% if V.busy|int != 1 %}
    RESPOND PREFIX=warn MSG="SCAN_FAIL ignored (no scan pending)"
  {% else %}
    UPDATE_DELAYED_GCODE ID=VISION_TIMEOUT DURATION=0
    UPDATE_DELAYED_GCODE ID=VISION_TICK    DURATION=0
    SET_GCODE_VARIABLE MACRO=VISION_STATE VARIABLE=busy VALUE=0
    M118 ACK_SCAN_FAIL job={printer["gcode_macro VISION_STATE"].job}

    {% set P = printer["gcode_macro SORTER_PARAMS"] %}
    {% set S = printer["gcode_macro STACK_STATE"] %}

    _MOVE_TOOL_SAFE X={P.scan_xy[0]} Y={P.scan_xy[1]}
    _MOVE_Z Z={P.scan_drop_z}
    VAC_ON
    _DWELL_MS P=150
    _MOVE_Z Z={P.travel_z}

    _MOVE_TOOL_SAFE X={P.reject_xy[0]} Y={P.reject_xy[1]}
    _MOVE_Z Z={P.reject_drop_z}
    M400
    _DWELL_MS P=120
    VAC_OFF
    _DWELL_MS P={P.dwell_release_ms}
    _RAISE_TO_TRAVEL

    {% set src = S.src_slot|int %}
    {% set t   = S.card_thickness|float %}
    {% set new_s1 = (S.start1_h - t)|float if src==1 else S.start1_h|float %}
    {% set new_s2 = (S.start2_h - t)|float if src==2 else S.start2_h|float %}
    {% set new_rej = (S.reject_h + t)|float %}
    SET_GCODE_VARIABLE MACRO=STACK_STATE VARIABLE=start1_h VALUE={new_s1}
    SET_GCODE_VARIABLE MACRO=STACK_STATE VARIABLE=start2_h VALUE={new_s2}
    SET_GCODE_VARIABLE MACRO=STACK_STATE VARIABLE=reject_h VALUE={new_rej}

    SET_GCODE_VARIABLE MACRO=STACK_STATE VARIABLE=next_start_slot VALUE={ 2 if src==1 else 1 }

    {% set remaining = (printer["gcode_macro ISTATE"].remaining|default(1))|int %}
    {% set next_remaining = remaining - 1 if remaining > 0 else 0 %}
    SET_GCODE_VARIABLE MACRO=ISTATE VARIABLE=remaining VALUE={next_remaining}
    {% if next_remaining > 0 %} SORTER_CYCLE_INTERACTIVE {% else %} RESPOND PREFIX=info MSG="Run complete." {% endif %}
  {% endif %}

[gcode_macro SORTER_CYCLE_INTERACTIVE]
description: One full cycle: pick → move to scan → wait for result
gcode:
  PICKUP_CARD
  MOVE_TO_SCAN

[gcode_macro RUN_SORTER_INTERACTIVE]
description: Run N cards; will home automatically if needed. Example: RUN_SORTER_INTERACTIVE COUNT=10 HOME=1
gcode:
  {% set COUNT = params.COUNT|default(1)|int %}
  {% set HOME  = params.HOME|default(0)|int %}
  {% set homed = (printer.toolhead.homed_axes|string)|lower %}
  {% if HOME == 1 or not ('x' in homed and 'y' in homed and 'z' in homed) %}
    G90
    G28
    _SAFE_RAISE
  {% endif %}
  SET_GCODE_VARIABLE MACRO=ISTATE VARIABLE=remaining VALUE={COUNT}
  { action_respond_info("Starting interactive run of %d card(s)" % (COUNT)) }
  SORTER_CYCLE_INTERACTIVE

[gcode_macro SHOW_STACKS]
description: Print current stack heights and card thickness
gcode:
  {% set S = printer["gcode_macro STACK_STATE"] %}
  { action_respond_info(
      "STACKS: start1=%.3f  start2=%.3f  finish1=%.3f  finish2=%.3f  reject=%.3f  (card=%.3f)" %
      (S.start1_h, S.start2_h, S.finish1_h, S.finish2_h, S.reject_h, S.card_thickness)
  ) }

# ===== Convenience: set scan park XYZ quickly =====
[gcode_macro SET_SCAN_PARK]
description: Set head park XYZ for scan wait; e.g., SET_SCAN_PARK X=175 Y=85 Z=30
gcode:
  {% set X = params.X|float %}
  {% set Y = params.Y|float %}
  {% set Z = params.Z|float %}
  SET_GCODE_VARIABLE MACRO=SORTER_PARAMS VARIABLE=scan_head_xy VALUE="{X}, {Y}"
  SET_GCODE_VARIABLE MACRO=SORTER_PARAMS VARIABLE=scan_head_z  VALUE={Z}
  { action_respond_info("Scan park set to X=%.2f Y=%.2f Z=%.2f" % (X,Y,Z)) }

# ===== Vibration helper (unchanged) =====
[gcode_macro VIBRATE_X]
description: Time-based, true jitter on X only; tiny step pulses with hard reversals; returns to start X
# Usage:
#   VIBRATE_X DURATION_MS=600 STEP=0.05 PULSE_MS=8 SPEED=12000 ACCEL=8000
# Params:
#   DURATION_MS  total buzz time (ms)
#   STEP         mm per half-stroke (tiny, e.g. 0.03–0.10)
#   PULSE_MS     dwell between flips (ms): smaller = buzzier
#   SPEED        feedrate (mm/min) for the tiny moves
#   ACCEL        temporary accel (mm/s^2) for snappy flips
gcode:
  {% set DURATION_MS = params.DURATION_MS|default(500)|int %}
  {% set STEP        = params.STEP|default(0.05)|float %}
  {% set PULSE_MS    = params.PULSE_MS|default(8)|int %}
  {% set SPEED       = params.SPEED|default(12000)|int %}
  {% set ACCEL       = params.ACCEL|default(8000)|int %}

  {% if DURATION_MS <= 0 or STEP <= 0.0 or SPEED <= 0 or ACCEL <= 0 %}
    { action_respond_info("VIBRATE_X: bad params; skipping") }
    RETURN
  {% endif %}

  {% set x0   = printer.toolhead.position.x|float %}
  {% set xmin = printer.configfile.settings.stepper_x.position_min|float %}
  {% set xmax = printer.configfile.settings.stepper_x.position_max|float %}
  {% set max_left  = x0 - xmin %}
  {% set max_right = xmax - x0 %}
  {% set max_ax = max_left if max_left < max_right else max_right %}
  {% set STEPc = STEP if STEP < max_ax else (max_ax - 0.01) %}
  {% if STEPc <= 0.01 %}
    { action_respond_info("VIBRATE_X: too close to X edge; skipping") }
    RETURN
  {% endif %}

  {% set cur = printer.toolhead.max_accel|int %}
  {% set cur_scv = printer.toolhead.square_corner_velocity|float %}
  {% set cur_vel = printer.toolhead.max_velocity|float %}
  SET_VELOCITY_LIMIT VELOCITY={cur_vel} ACCEL={ACCEL} ACCEL_TO_DECEL={ACCEL} SQUARE_CORNER_VELOCITY=0

  {% set cycle_ms = (PULSE_MS*2) %}
  {% set cycles = (DURATION_MS // cycle_ms) | int %}
  {% if cycles < 1 %}{% set cycles = 1 %}{% endif %}

  G90
  G91
  {% for i in range(cycles) %}
    G1 X{  STEPc} F{SPEED}
    G4 P{PULSE_MS}
    G1 X{ -STEPc} F{SPEED}
    G4 P{PULSE_MS}
  {% endfor %}
  G90
  G1 X{ x0 } F{SPEED}
  SET_VELOCITY_LIMIT VELOCITY={cur_vel} ACCEL={cur} ACCEL_TO_DECEL={cur} SQUARE_CORNER_VELOCITY={cur_scv}
